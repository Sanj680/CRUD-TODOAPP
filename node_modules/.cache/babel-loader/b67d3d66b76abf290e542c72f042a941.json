{"ast":null,"code":"import e from \"compute-scroll-into-view\";\n\nlet t = e => !1 === e ? {\n  block: \"end\",\n  inline: \"nearest\"\n} : (e => e === Object(e) && 0 !== Object.keys(e).length)(e) ? e : {\n  block: \"start\",\n  inline: \"nearest\"\n};\n\nfunction o(o, l) {\n  let n = o.isConnected || o.ownerDocument.documentElement.contains(o);\n  if ((e => \"object\" == typeof e && \"function\" == typeof e.behavior)(l)) return l.behavior(n ? e(o, l) : []);\n  if (!n) return;\n  let r = t(l),\n      c = e(o, r),\n      i = (\"scrollBehavior\" in document.body.style);\n  c.forEach(e => {\n    let {\n      el: t,\n      top: o,\n      left: l\n    } = e;\n    t.scroll && i ? t.scroll({\n      top: o,\n      left: l,\n      behavior: r.behavior\n    }) : (t.scrollTop = o, t.scrollLeft = l);\n  });\n}\n\nexport { o as default };","map":{"version":3,"sources":["../src/index.ts"],"names":["options","Object","keys","length","behavior","getOptions","block","inline","target","isTargetAttached","isConnected","ownerDocument","documentElement","contains","compute","actions","computeOptions","canSmoothScroll","document","body","style","forEach","_ref","el","top","left","scroll","scrollTop","scrollLeft"],"mappings":";;AA6BA,IAUIK,CAAAA,GAAcL,CAAAA,IAAAA,CAEA,CAFAA,KAEZA,CAFYA,GAGP;AAAEM,EAAAA,KAAAA,EAAO,KAAT;AAAgBC,EAAAA,MAAAA,EAAQ;AAAxB,CAHOP,GAThBA,CAAAA,CAAAA,IAEAA,CAAAA,KAAYC,MAAAA,CAAOD,CAAPC,CAAZD,IAA+D,MAAhCC,MAAAA,CAAOC,IAAPD,CAAYD,CAAZC,EAAqBE,MAFpDH,EAe6BA,CAf7BA,IAiBSA,CAjBTA,GAqBO;AAAEM,EAAAA,KAAAA,EAAO,OAAT;AAAkBC,EAAAA,MAAAA,EAAQ;AAA1B,CAtBT;;AAuCwB,SAAA,CAAA,CACtBC,CADsB,EAEtBR,CAFsB,EAEtBA;AAGA,MAAIS,CAAAA,GACFD,CAAAA,CAAOE,WAAPF,IACAA,CAAAA,CAAOG,aAAPH,CAAsBI,eAAtBJ,CAAuCK,QAAvCL,CAAgDA,CAAhDA,CAFF;AAII,MA1CJR,CAAAA,CAAAA,IAEmB,YAAA,OAAZA,CAAY,IAAuC,cAAA,OAArBA,CAAAA,CAAQI,QAF7CJ,EA0C8BA,CA1C9BA,CA0CI,EACK,OAAA,CAAA,CAAQI,QAAR,CAAiBK,CAAAA,GAAmBK,CAAAA,CAAQN,CAARM,EAAgBd,CAAhBc,CAAnBL,GAA8C,EAA/D,CAAA;AAIT,MAAA,CAAKA,CAAL,EACE;AAIE,MAAA,CAAA,GAAiBJ,CAAAA,CAAWL,CAAXK,CAAjB;AAAA,MACAU,CAAAA,GAAUD,CAAAA,CAAQN,CAARM,EAAgBE,CAAhBF,CADV;AAAA,MAEAG,CAAAA,IAAkB,oBAAoBC,QAAAA,CAASC,IAATD,CAAcE,KAApDH,CAFA;AAIJF,EAAAA,CAAAA,CAAQM,OAARN,CAAgBO,CAAAA,IAAAA;AAAuB,QAAA;AAAtBC,MAAAA,EAAAA,EAAEA,CAAoB;AAAhBC,MAAAA,GAAAA,EAAAA,CAAgB;AAAhBA,MAAAA,IAAAA,EAAKC;AAAW,QAAA,CAAA;AAGjCF,IAAAA,CAAAA,CAAGG,MAAHH,IAAaN,CAAbM,GACFA,CAAAA,CAAGG,MAAHH,CAAU;AAAEC,MAAAA,GAAAA,EAAAA,CAAF;AAAOC,MAAAA,IAAAA,EAAAA,CAAP;AAAarB,MAAAA,QAAAA,EAAUY,CAAAA,CAAeZ;AAAtC,KAAVmB,CADEA,IAGFA,CAAAA,CAAGI,SAAHJ,GAAeC,CAAfD,EACAA,CAAAA,CAAGK,UAAHL,GAAgBE,CAJdF;AAKJ,GARFR;AAUF;;AAAA,SAAA,CAAA,IAAA,OAAA","sourcesContent":["import compute from 'compute-scroll-into-view'\nimport type {\n  Options as BaseOptions,\n  ScrollAction,\n} from 'compute-scroll-into-view'\n\n/** @public */\nexport type Options<T = unknown> =\n  | StandardBehaviorOptions\n  | CustomBehaviorOptions<T>\n\n/** @public */\nexport interface StandardBehaviorOptions extends BaseOptions {\n  /**\n   * @defaultValue 'auto\n   */\n  behavior?: ScrollBehavior\n}\n\n/** @public */\nexport interface CustomBehaviorOptions<T = unknown> extends BaseOptions {\n  behavior: CustomScrollBehaviorCallback<T>\n}\n\n/** @public */\nexport type CustomScrollBehaviorCallback<T = unknown> = (\n  actions: ScrollAction[]\n) => T\n\nlet isStandardScrollBehavior = (\n  options: any\n): options is StandardBehaviorOptions =>\n  options === Object(options) && Object.keys(options).length !== 0\n\nlet isCustomScrollBehavior = <T = unknown>(\n  options: any\n): options is CustomBehaviorOptions<T> =>\n  typeof options === 'object' ? typeof options.behavior === 'function' : false\n\nlet getOptions = (options: any): StandardBehaviorOptions => {\n  // Handle alignToTop for legacy reasons, to be compatible with the spec\n  if (options === false) {\n    return { block: 'end', inline: 'nearest' }\n  }\n\n  if (isStandardScrollBehavior(options)) {\n    // compute.ts ensures the defaults are block: 'center' and inline: 'nearest', to conform to the spec\n    return options\n  }\n\n  // if options = {}, options = true or options = null, based on w3c web platform test\n  return { block: 'start', inline: 'nearest' }\n}\n\n// Some people might use both \"auto\" and \"ponyfill\" modes in the same file, so we also provide a named export so\n// that imports in userland code (like if they use native smooth scrolling on some browsers, and the ponyfill for everything else)\n// the named export allows this `import {auto as autoScrollIntoView, ponyfill as smoothScrollIntoView} from ...`\n/** @public */\nexport default function scrollIntoView<T>(\n  target: Element,\n  options: CustomBehaviorOptions<T>\n): T\n/** @public */\nexport default function scrollIntoView(\n  target: Element,\n  options?: StandardBehaviorOptions | boolean\n): void\n/** @public */\nexport default function scrollIntoView<T = unknown>(\n  target: Element,\n  options?: StandardBehaviorOptions | CustomBehaviorOptions<T> | boolean\n): T | void {\n  // Browsers treats targets that aren't in the dom as a no-op and so should we\n  let isTargetAttached =\n    target.isConnected ||\n    target.ownerDocument!.documentElement!.contains(target)\n\n  if (isCustomScrollBehavior<T>(options)) {\n    return options.behavior(isTargetAttached ? compute(target, options) : [])\n  }\n\n  // Don't do anything if using a standard behavior on an element that is not in the document\n  if (!isTargetAttached) {\n    return\n  }\n\n  // @TODO see if it's possible to avoid this assignment\n  let computeOptions = getOptions(options)\n  let actions = compute(target, computeOptions)\n  let canSmoothScroll = 'scrollBehavior' in document.body.style\n\n  actions.forEach(({ el, top, left }) => {\n    // browser implements the new Element.prototype.scroll API that supports `behavior`\n    // and guard window.scroll with supportsScrollBehavior\n    if (el.scroll && canSmoothScroll) {\n      el.scroll({ top, left, behavior: computeOptions.behavior })\n    } else {\n      el.scrollTop = top\n      el.scrollLeft = left\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"module"}